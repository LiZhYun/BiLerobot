#!/usr/bin/env python3

# Copyright 2024 The HuggingFace Inc. team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Teleoperation script for controlling a virtual BiSO100 arm in ManiSkill environment 
using a real SO100 leader arm.

This script uses calibration data generated by generate_bi_so100_calibration_interactive.py
to map leader arm positions to virtual arm actions.

Example usage:
    python examples/teleoperate_bi_so100_with_real_leader.py \
        --leader-ids=left_leader,right_leader \
        --teleop-ports=/dev/ttyACM0,/dev/ttyACM1 \
        --calibration-files=path/to/left.json,path/to/right.json \
        --env-id=BiSO100OpenLid-v1 \
        --fps=30
"""

import argparse
import json
import logging
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List

import gymnasium as gym
import numpy as np

import bi_lerobot  # Import to register ManiSkill environments

# Import LeRobot teleoperator
from lerobot.common.teleoperators import Teleoperator
from lerobot.common.teleoperators.so100_leader import SO100LeaderConfig
from lerobot.common.teleoperators import make_teleoperator_from_config
from lerobot.common.utils.utils import init_logging
from lerobot.common.constants import HF_LEROBOT_CALIBRATION

logger = logging.getLogger(__name__)


@dataclass
class VirtualBiSO100Config:
    """Configuration for virtual BiSO100 robot in ManiSkill"""
    env_id: str = "BiSO100OpenLid-v1"
    robot_uids: str = "bi_so100"
    obs_mode: str = "none"
    render_mode: str = "human"
    sim_backend: str = "auto"


class VirtualBiSO100Robot:
    """Virtual BiSO100 robot interface for ManiSkill environment"""
    
    def __init__(self, config: VirtualBiSO100Config, leader_to_arm_map: Dict[str, str], leader_to_calib_map: Dict[str, str]):
        self.config = config
        self.leader_to_arm_map = leader_to_arm_map
        self.env = None
        self.robot = None
        self.target_joints = None
        self.p_gain = None

        # Load and remap calibrations for each leader
        self.calibrations = {}
        for leader_id, calib_file in leader_to_calib_map.items():
            calib_data = self._load_calibration(calib_file)
            
            calibrated_arm = calib_data["metadata"].get("virtual_arm")
            target_arm = self.leader_to_arm_map[leader_id]
            
            if calibrated_arm and calibrated_arm != target_arm:
                logger.warning(
                    f"Calibration file for leader '{leader_id}' is for '{calibrated_arm}' arm, "
                    f"but it will control the '{target_arm}' arm. Remapping calibration data."
                )
                calib_data = self._remap_calibration_data(calib_data, source_arm=calibrated_arm, target_arm=target_arm)
            
            self.calibrations[leader_id] = calib_data
        
        # Initialize environment
        self._setup_environment()
        
    def _load_calibration(self, calibration_file: str) -> Dict[str, Any]:
        """Load calibration data from file"""
        calibration_path = Path(calibration_file)
        if not calibration_path.exists():
            raise FileNotFoundError(f"Calibration file not found: {calibration_file}")
        
        with open(calibration_path, 'r') as f:
            calibration_data = json.load(f)
        
        logger.info(f"Loaded calibration from: {calibration_file}")
        return calibration_data
    
    def _remap_calibration_data(self, calib_data: Dict[str, Any], source_arm: str, target_arm: str) -> Dict[str, Any]:
        """Dynamically remap calibration data from one arm to another."""
        if source_arm == target_arm:
            return calib_data

        remapped_calib = calib_data.copy()
        new_calib_data = {}
        new_joint_mapping = {}

        if source_arm == "right" and target_arm == "left":
            index_offset, suffix_to_remove, suffix_to_add = -6, "_2", ""
        elif source_arm == "left" and target_arm == "right":
            index_offset, suffix_to_remove, suffix_to_add = 6, "", "_2"
        else:
            logger.error(f"Unsupported calibration remapping from '{source_arm}' to '{target_arm}'")
            return calib_data

        for leader_joint, calib in calib_data["calibration_data"].items():
            new_calib = calib.copy()
            original_vjoint = calib["virtual_joint"]
            
            new_vjoint = original_vjoint.removesuffix(suffix_to_remove) if suffix_to_remove else original_vjoint
            new_vjoint += suffix_to_add
            
            new_calib["virtual_joint"] = new_vjoint
            new_calib["virtual_joint_index"] = calib["virtual_joint_index"] + index_offset
            
            new_calib_data[leader_joint] = new_calib
            new_joint_mapping[leader_joint] = new_vjoint

        remapped_calib["calibration_data"] = new_calib_data
        remapped_calib["metadata"]["joint_mapping"] = new_joint_mapping
        remapped_calib["metadata"]["virtual_arm"] = target_arm
        remapped_calib["metadata"]["arm_mapping"] = f"{calib_data['metadata']['leader_id']} -> {target_arm} (remapped)"
        
        return remapped_calib
    
    def _setup_environment(self):
        """Setup the ManiSkill environment"""
        logger.info(f"Loading environment: {self.config.env_id}")
        
        self.env = gym.make(
            self.config.env_id,
            obs_mode=self.config.obs_mode,
            render_mode=self.config.render_mode,
            sim_backend=self.config.sim_backend,
            robot_uids=self.config.robot_uids
        )
        
        obs, _ = self.env.reset()
        
        if hasattr(self.env.unwrapped, "agent"):
            self.robot = self.env.unwrapped.agent.robot
        elif hasattr(self.env.unwrapped, "agents") and len(self.env.unwrapped.agents) > 0:
            self.robot = self.env.unwrapped.agents[0]
        else:
            raise RuntimeError("Could not find robot in environment")
        
        logger.info(f"Robot loaded: {type(self.robot)}")
        
        self.target_joints = np.zeros(12)
        self.p_gain = np.ones(12)
        self.p_gain[[5, 11]] = 0.04
        
        current_joints = self._get_mapped_joints()
        self.target_joints = current_joints.copy()
    
    def _get_mapped_joints(self):
        """Get the current joint positions from the robot and map them correctly."""
        if self.robot is None: return np.zeros(12)
        full_joints = self.robot.get_qpos()
        if hasattr(full_joints, 'numpy'): full_joints = full_joints.numpy()
        if full_joints.ndim > 1: full_joints = full_joints.squeeze()
        
        mapped_joints = np.zeros(12)
        if len(full_joints) >= 12:
            mapped_joints[0:6] = full_joints[[0, 2, 4, 6, 8, 10]]
            mapped_joints[6:12] = full_joints[[1, 3, 5, 7, 9, 11]]
        return mapped_joints
    
    def _apply_calibration(self, leader_id: str, leader_action: Dict[str, float]):
        """Apply calibration mapping from one leader to its virtual arm."""
        calibration = self.calibrations[leader_id]
        
        for leader_joint, leader_pos_deg in leader_action.items():
            leader_joint_name = leader_joint.removesuffix('.pos')
            if leader_joint_name in calibration["calibration_data"]:
                calib = calibration["calibration_data"][leader_joint_name]
                leader_pos_rad = np.radians(leader_pos_deg)
                
                virtual_pos_rad = calib["scale_factor"] * leader_pos_rad + calib["offset"]
                
                if leader_joint_name == "gripper":
                    virtual_range_min = calib.get("virtual_range_min", 0.0)
                    virtual_range_max = calib.get("virtual_range_max", 1.7)
                    virtual_pos_rad = np.interp(virtual_pos_rad, [virtual_range_min, virtual_range_max], [0.0, 1.7])

                self.target_joints[calib["virtual_joint_index"]] = virtual_pos_rad
    
    @property
    def action_features(self) -> Dict[str, type]:
        """Return action features compatible with lerobot interface"""
        all_joints = set()
        for calib_data in self.calibrations.values():
            for leader_joint in calib_data['calibration_data'].keys():
                all_joints.add(f"{leader_joint}.pos")
        return {joint: float for joint in sorted(list(all_joints))}
    
    @property
    def is_connected(self) -> bool:
        """Check if virtual robot is connected"""
        return self.env is not None
    
    def connect(self) -> None:
        """Connect to virtual robot"""
        if not self.is_connected:
            self._setup_environment()
        logger.info("Virtual BiSO100 robot connected")
    
    def send_action(self, actions: Dict[str, Dict[str, Any]]) -> Dict[str, Any]:
        """Send action to virtual robot"""
        if not self.is_connected:
            raise RuntimeError("Virtual robot is not connected")
        
        for leader_id, leader_action in actions.items():
            self._apply_calibration(leader_id, leader_action)
        
        current_joints = self._get_mapped_joints()
        control_action = np.zeros(12)
        for i in range(12):
            control_action[i] = self.p_gain[i] * (self.target_joints[i] - current_joints[i])
        
        self.env.step(control_action)
        self.env.render()
        
        return self.target_joints
    
    def disconnect(self) -> None:
        """Disconnect from virtual robot"""
        if self.env:
            self.env.close()
            self.env = None
        logger.info("Virtual BiSO100 robot disconnected")


def teleop_loop(
    teleops: List[Teleoperator], robot: VirtualBiSO100Robot, fps: int, duration: float | None = None
):
    """Main teleoperation loop for dual-arm control"""
    start = time.perf_counter()
    logger.info("Starting teleoperation loop... Use Ctrl+C to stop")
    step_counter, warmup_steps = 0, 50
    
    while True:
        loop_start = time.perf_counter()
        
        leader_actions = {teleop.config.id: teleop.get_action() for teleop in teleops}
        
        if step_counter >= warmup_steps:
            robot.send_action(leader_actions)
        
        dt_s = time.perf_counter() - loop_start
        if (remaining_time := 1 / fps - dt_s) > 0:
            time.sleep(remaining_time)
        
        if step_counter % 30 == 0 and step_counter >= warmup_steps:
            print("\n" + "=" * 50)
            print("DUAL ARM TELEOPERATION STATUS")
            print("=" * 50)
            for teleop in teleops:
                leader_id = teleop.config.id
                arm_id = robot.leader_to_arm_map[leader_id]
                print(f"--- Leader: {leader_id} -> Virtual Arm: {arm_id.upper()} ---")
                for joint, val in leader_actions[leader_id].items():
                    print(f"  {joint:<20}: {val:>8.2f}")
            print(f"\nLoop time: {1000 * (time.perf_counter() - loop_start):.2f}ms")
            
        step_counter += 1
        if duration and (time.perf_counter() - start) >= duration:
            break


def main():
    parser = argparse.ArgumentParser(
        description="Teleoperate virtual BiSO100 arm with two real SO100 leaders"
    )
    parser.add_argument("--leader-ids", type=str, default="left_leader,right_leader", help="Comma-separated leader arm identifiers (e.g., left_leader,right_leader)")
    parser.add_argument("--teleop-ports", type=str, default="/dev/ttyACM0,/dev/ttyACM1", help="Comma-separated SO100 teleoperator ports (e.g., /dev/ttyACM0,/dev/ttyACM1)")
    parser.add_argument("--calibration-files", type=str, default=str(HF_LEROBOT_CALIBRATION / "virtual_robots/bi_so100/left_leader_to_left_arm_interactive.json") + "," + str(HF_LEROBOT_CALIBRATION / "virtual_robots/bi_so100/right_leader_to_right_arm_interactive.json"), help="Comma-separated paths to calibration files")
    parser.add_argument("--env-id", type=str, default="BiSO100OpenLid-v1", help="ManiSkill environment ID")
    parser.add_argument("--fps", type=int, default=30, help="Control loop frequency")
    parser.add_argument("--duration", type=float, help="Duration to run teleoperation (seconds)")
    parser.add_argument("--log-level", type=str, default="INFO", choices=["DEBUG", "INFO", "WARNING", "ERROR"], help="Logging level")
    
    # "/home/zhiyuan/.cache/huggingface/lerobot/calibration/virtual_robots/bi_so100/left_leader_to_left_arm_interactive.json,/home/zhiyuan/.cache/huggingface/lerobot/calibration/virtual_robots/bi_so100/right_leader_to_right_arm_interactive.json"

    args = parser.parse_args()
    
    init_logging()
    logger.setLevel(getattr(logging, args.log_level))
    
    leader_ids = args.leader_ids.split(',')
    teleop_ports = args.teleop_ports.split(',')
    calibration_files = args.calibration_files.split(',')

    if not (len(leader_ids) == len(teleop_ports) == len(calibration_files) == 2):
        raise ValueError("Must provide exactly two comma-separated values for leader-ids, teleop-ports, and calibration-files.")

    print("BiSO100 Dual Arm Virtual Teleoperation")
    print("=" * 50)
    
    # Assumes first leader controls left arm, second controls right
    leader_to_arm_map = {leader_ids[0]: "left", leader_ids[1]: "right"}
    leader_to_calib_map = {leader_ids[0]: calibration_files[0], leader_ids[1]: calibration_files[1]}

    for i in range(2):
        print(f"Leader {i+1} ('{leader_ids[i]}') on port {teleop_ports[i]} controls '{leader_to_arm_map[leader_ids[i]]}' arm.")
        print(f"  using calibration: {calibration_files[i]}")

    print(f"Environment: {args.env_id}, FPS: {args.fps}")
    print("=" * 50)
    
    teleops = [
        make_teleoperator_from_config(SO100LeaderConfig(port=port, id=lid))
        for lid, port in zip(leader_ids, teleop_ports)
    ]
    
    robot = VirtualBiSO100Robot(
        config=VirtualBiSO100Config(env_id=args.env_id),
        leader_to_arm_map=leader_to_arm_map,
        leader_to_calib_map=leader_to_calib_map
    )
    
    try:
        for teleop in teleops: teleop.connect()
        robot.connect()
        logger.info("All devices connected successfully")
        teleop_loop(teleops, robot, args.fps, duration=args.duration)
    except KeyboardInterrupt:
        logger.info("Teleoperation stopped by user")
    except Exception as e:
        logger.error(f"Error during teleoperation: {e}", exc_info=True)
        return 1
    finally:
        for teleop in teleops: teleop.disconnect()
        robot.disconnect()
        logger.info("All devices disconnected")
    
    return 0


if __name__ == "__main__":
    exit(main()) 